Privacy:
  -> This application will not collect any metadata if it's applicable
  -> This application does not require public identity like phone number/email
  -> This application will not bind any purchase and system records to anonymous user accounts if it's applicable

Data needed to run the application that you must consent:
  -> Bank Card's First 6 number (Bank Identification Number AKA BIN), this data does not bind to user's account in the service provider's service system
  -> Bank Card's Last 4 number, this data does not bind to user's account in the service provider's service system
  -> The IP address that you give to payment provider(Rapyd) when making payment, this data does not bind to user's account in the service provider's service system
  -> Server's file will have a last modification/read or write time to make sure that the anonymous user makes payment.

Security(MFA):
  -> Because of the fact that common MFA(Multi factor authentication) requires the collection of public identity like email or phone number, this do means that it's not
     possible to prevent security and privacy issues after data leakage for example stuffs like scam, spam, phising, social engineering could in theory happens. This is a trade
     off because in some sense, MFA is no longer available hence the account will be more vulnerable but it guarantees these public identity leakage can be prevented hence the
     described problems will be reduced and not have any impacts to user/client.

Security(Cryptographic Keys):
  -> Because of the fact that this still uses non-post quantum public key cryptography like ED25519(Cryptographic Signature) as a passwordless public key login mechanism,
     when QC(Quantum Computer) or QS(Quantum Server) becomes commonly available, this can poses threat to the login mechanism
  -> Because of the fact that this still uses non-post quantum public key cryptography like ED25519(Cryptographic Signature) as a seal, even though the ED25519 PK is not known
     to service provider but when QC or QS becomes commonly available, this can poses threat to the seal mechanism that had on each of the endpoint encrypted file content.
  -> Any files encrypted and signed locally(endpoint) in theory won't have confidentiality and security issues when the service provider gets hacked, but it does not mean that
     endpoint won't be compromised. The target was switched from attacking the server/service provider to attack endpoint/client device. If you can keep the cryptographic keys
     secure and private, then the attack of hackers or service provider's insider's attacks won't affect the endpoint or client's device.

Security(Server/Service Provider):
  -> Users by default and in all circumstances, mustn't trust server/service provider at all costs, hence this whole project was based on "Zero Trust/Zero Access" towards the
     service provider.

Terms(Users/Client):
  -> Users or client must keep their cryptographic keys secure and private, the server and service provider because of the anonymity and privacy focused feature, in the case that
     client/users keys are lost, the server and service provider won't able to recover those keys on users behalf. This itself is both a strength and weakness, because this
     guarantees that only users able to decrypt their own file contents but if users lost their keys, the decryption process will fail and users won't able to decrypt their files.
  -> If users lost their recovery keys(available when register), and their account gets lost, server won't be able to do anything, users must at all cost keep their recovery keys
     private and secure. 
  -> In the case that users preserve their recovery keys, but they lost the keys that they used for encrypting the files, the server/service provider also can't do anything.

Note: This whole project was built based on the consideration of zero trust/zero access and post data leakage security. In theory the server/service provider even if it was
      affected by virus/ransomware users/client can be rest assured that their files can't be decrypted by hackers or insiders. Hence this kind of design approach will greatly
      reduce the motives that the hacker/insider to wreak havoc to the system/server/service provider.
